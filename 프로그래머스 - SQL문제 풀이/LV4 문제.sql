-- 보호소에서 중성화한 동물 --
SELECT I.ANIMAL_ID, I.ANIMAL_TYPE, I.NAME
FROM ANIMAL_INS I
JOIN ANIMAL_OUTS O
ON I.ANIMAL_ID = O.ANIMAL_ID -- 두개의 테이블을 ID를  통해 JOIN한다.
WHERE I.SEX_UPON_INTAKE LIKE '%Intact%' AND 
(O.SEX_UPON_OUTCOME LIKE "%Spayed%" OR O.SEX_UPON_OUTCOME LIKE "%Neutered%") -- 해당 조건에 맞는 애들만 가져온다.
ORDER BY I.ANIMAL_ID


-- 5월 식품들의 총매출 조회하기 --
SELECT P.PRODUCT_ID, P.PRODUCT_NAME, P.PRICE*O.AMOUNT AS TOTAL_SALES
FROM FOOD_PRODUCT P
JOIN(
SELECT PRODUCT_ID, SUM(AMOUNT) AS AMOUNT -- 미리 AMOUNT를 구할수있도록 그룹화를 통해 얻어온 테이블을 JOIN한다.
FROM FOOD_ORDER
WHERE LEFT(PRODUCE_DATE,7) = '2022-05'
GROUP BY PRODUCT_ID) AS O
ON P.PRODUCT_ID = O.PRODUCT_ID
ORDER BY TOTAL_SALES DESC, PRODUCT_ID


-- 식품분류별 가장 비싼 식품의 정보 조회하기 --
SELECT P.CATEGORY, MP.MAX_PRICE, P.PRODUCT_NAME
FROM FOOD_PRODUCT P
JOIN(
SELECT CATEGORY, MAX(PRICE) AS MAX_PRICE
FROM FOOD_PRODUCT
WHERE CATEGORY IN ('과자', '국', '김치', '식용유') -- 카테고리가 해당 하는 애들만 카테고리로 그룹화하여 MAX가격을 가져온다.
GROUP BY CATEGORY) AS MP
ON P.CATEGORY = MP.CATEGORY -- 그렇게 가져온 정보를 테이블과 JOIN한다.
WHERE P.CATEGORY = MP.CATEGORY AND P.PRICE = MP.MAX_PRICE -- JOIN한 테이블에서 카테고리가 같고 가격이 같은 애들만 출력
ORDER BY MP.MAX_PRICE DESC


-- 서울에 위치한 식당 목록 출력하기 --
SELECT I.REST_ID, I.REST_NAME, I.FOOD_TYPE, I.FAVORITES, I.ADDRESS, S.SCORE
FROM REST_INFO I
JOIN(
SELECT REST_ID, ROUND(SUM(REVIEW_SCORE)/COUNT(REST_ID),2) AS SCORE
FROM REST_REVIEW
GROUP BY REST_ID
) AS S
ON I.REST_ID = S.REST_ID
WHERE LEFT(I.ADDRESS,2) = '서울'
ORDER BY S.SCORE DESC, I.FAVORITES DESC

select
    A.REST_ID,
    A.REST_NAME,
    A.FOOD_TYPE,
    A.FAVORITES,
    A.ADDRESS,
    ROUND(AVG(B.REVIEW_SCORE),2) AS SCORE  
from
    REST_INFO A, REST_REVIEW B -- FROM으로 두개를 불러와서 할수도있다.
where
    A.REST_ID = B.REST_ID and
    A.ADDRESS LIKE "서울%"
group by A.REST_ID
ORDER BY SCORE DESC ,A.FAVORITES DESC


-- 년,월,성별 별 상품 구매 회원 수 구하기 --
SELECT YEAR(S.SALES_DATE) AS YEAR, 
        MONTH(S.SALES_DATE) AS MONTH, 
        I.GENDER, COUNT(I.USER_ID) AS USERS -- 거기서 COUNT한다면 같은 ID가 중복하지 않는 ID의 개수가 나온다.
FROM (
SELECT *
FROM ONLINE_SALE
GROUP BY YEAR(SALES_DATE), MONTH(SALES_DATE), USER_ID -- 같은 년,월에 여러 번 시킨 USER_ID의 중복을 제거한 테이블과
) AS S
JOIN USER_INFO I
ON S.USER_ID = I.USER_ID -- USER_INFO를 JOIN한곳에서 탐색한다.
WHERE I.GENDER IS NOT NULL -- 성별이 NULL인 애들을 제외하고
GROUP BY YEAR, MONTH, I.GENDER -- 년,월,성별로 그룹화 한다.
ORDER BY YEAR,MONTH,I.GENDER

SELECT YEAR(S.SALES_DATE) AS YEAR, 
        MONTH(S.SALES_DATE) AS MONTH, 
        I.GENDER, COUNT(DISTINCT I.USER_ID) AS USERS -- DISTINCT를 이용하여 바로 중복된 ID를 지울수도 있다..
FROM ONLINE_SALE S
JOIN USER_INFO I
ON S.USER_ID = I.USER_ID
WHERE I.GENDER IS NOT NULL
GROUP BY YEAR, MONTH, I.GENDER
ORDER BY YEAR,MONTH,I.GENDER


-- 우유와 요거트가 담긴 장바구니 --
SELECT Y.CART_ID
FROM (
SELECT DISTINCT CART_ID --요거트 담긴 카트만 중복 없이 가져온다.
FROM CART_PRODUCTS 
WHERE NAME = 'Yogurt') AS Y
JOIN(
SELECT DISTINCT CART_ID -- 우유가 담긴 카트만 중복 없이 가져온다.
FROM CART_PRODUCTS 
WHERE NAME = 'Milk') AS M
ON Y.CART_ID = M.CART_ID -- 두개의 테이블에서 ID가 같은것만 출력
ORDER BY Y.CART_ID

SELECT CART_ID
FROM CART_PRODUCTS
WHERE NAME = 'Milk' AND CART_ID IN ( -- 테이블을 둘다 구하는게 아니라 한쪽만 구하고 다른한쪽으로 이런식으로도 구현가능하다.
    SELECT CART_ID
    FROM CART_PRODUCTS
    WHERE NAME = 'Yogurt'
)
ORDER BY CART_ID;


-- 취소되지 않은 진료 예약 조회하기 --
SELECT A.APNT_NO, P.PT_NAME,P.PT_NO, D.MCDP_CD, D.DR_NAME, A.APNT_YMD
FROM DOCTOR D
JOIN APPOINTMENT A
ON A.APNT_CNCL_YN = 'N' AND D.DR_ID = A.MDDR_ID AND A.MCDP_CD = 'CS' -- 일단 의사 테이블과 진료테이블에서 해당 조건에 만족하는 진료만 가져온다.
JOIN PATIENT P
ON A.PT_NO = P.PT_NO -- 가져온 정보에서 환자테이블에서 해당 환자 데이터를 가져온다.
WHERE LEFT(A.APNT_YMD,10) = '2022-04-13' -- 해당일에 속하는 데이터만 출력
ORDER BY A.APNT_YMD