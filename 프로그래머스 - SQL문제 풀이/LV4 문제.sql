-- 보호소에서 중성화한 동물 --
SELECT I.ANIMAL_ID, I.ANIMAL_TYPE, I.NAME
FROM ANIMAL_INS I
JOIN ANIMAL_OUTS O
ON I.ANIMAL_ID = O.ANIMAL_ID -- 두개의 테이블을 ID를  통해 JOIN한다.
WHERE I.SEX_UPON_INTAKE LIKE '%Intact%' AND 
(O.SEX_UPON_OUTCOME LIKE "%Spayed%" OR O.SEX_UPON_OUTCOME LIKE "%Neutered%") -- 해당 조건에 맞는 애들만 가져온다.
ORDER BY I.ANIMAL_ID


-- 5월 식품들의 총매출 조회하기 --
SELECT P.PRODUCT_ID, P.PRODUCT_NAME, P.PRICE*O.AMOUNT AS TOTAL_SALES
FROM FOOD_PRODUCT P
JOIN(
SELECT PRODUCT_ID, SUM(AMOUNT) AS AMOUNT -- 미리 AMOUNT를 구할수있도록 그룹화를 통해 얻어온 테이블을 JOIN한다.
FROM FOOD_ORDER
WHERE LEFT(PRODUCE_DATE,7) = '2022-05'
GROUP BY PRODUCT_ID) AS O
ON P.PRODUCT_ID = O.PRODUCT_ID
ORDER BY TOTAL_SALES DESC, PRODUCT_ID


-- 식품분류별 가장 비싼 식품의 정보 조회하기 --
SELECT P.CATEGORY, MP.MAX_PRICE, P.PRODUCT_NAME
FROM FOOD_PRODUCT P
JOIN(
SELECT CATEGORY, MAX(PRICE) AS MAX_PRICE
FROM FOOD_PRODUCT
WHERE CATEGORY IN ('과자', '국', '김치', '식용유') -- 카테고리가 해당 하는 애들만 카테고리로 그룹화하여 MAX가격을 가져온다.
GROUP BY CATEGORY) AS MP
ON P.CATEGORY = MP.CATEGORY -- 그렇게 가져온 정보를 테이블과 JOIN한다.
WHERE P.CATEGORY = MP.CATEGORY AND P.PRICE = MP.MAX_PRICE -- JOIN한 테이블에서 카테고리가 같고 가격이 같은 애들만 출력
ORDER BY MP.MAX_PRICE DESC


-- 서울에 위치한 식당 목록 출력하기 --
SELECT I.REST_ID, I.REST_NAME, I.FOOD_TYPE, I.FAVORITES, I.ADDRESS, S.SCORE
FROM REST_INFO I
JOIN(
SELECT REST_ID, ROUND(SUM(REVIEW_SCORE)/COUNT(REST_ID),2) AS SCORE
FROM REST_REVIEW
GROUP BY REST_ID
) AS S
ON I.REST_ID = S.REST_ID
WHERE LEFT(I.ADDRESS,2) = '서울'
ORDER BY S.SCORE DESC, I.FAVORITES DESC

select
    A.REST_ID,
    A.REST_NAME,
    A.FOOD_TYPE,
    A.FAVORITES,
    A.ADDRESS,
    ROUND(AVG(B.REVIEW_SCORE),2) AS SCORE  
from
    REST_INFO A, REST_REVIEW B -- FROM으로 두개를 불러와서 할수도있다.
where
    A.REST_ID = B.REST_ID and
    A.ADDRESS LIKE "서울%"
group by A.REST_ID
ORDER BY SCORE DESC ,A.FAVORITES DESC


-- 년,월,성별 별 상품 구매 회원 수 구하기 --
SELECT YEAR(S.SALES_DATE) AS YEAR, 
        MONTH(S.SALES_DATE) AS MONTH, 
        I.GENDER, COUNT(I.USER_ID) AS USERS -- 거기서 COUNT한다면 같은 ID가 중복하지 않는 ID의 개수가 나온다.
FROM (
SELECT *
FROM ONLINE_SALE
GROUP BY YEAR(SALES_DATE), MONTH(SALES_DATE), USER_ID -- 같은 년,월에 여러 번 시킨 USER_ID의 중복을 제거한 테이블과
) AS S
JOIN USER_INFO I
ON S.USER_ID = I.USER_ID -- USER_INFO를 JOIN한곳에서 탐색한다.
WHERE I.GENDER IS NOT NULL -- 성별이 NULL인 애들을 제외하고
GROUP BY YEAR, MONTH, I.GENDER -- 년,월,성별로 그룹화 한다.
ORDER BY YEAR,MONTH,I.GENDER

SELECT YEAR(S.SALES_DATE) AS YEAR, 
        MONTH(S.SALES_DATE) AS MONTH, 
        I.GENDER, COUNT(DISTINCT I.USER_ID) AS USERS -- DISTINCT를 이용하여 바로 중복된 ID를 지울수도 있다..
FROM ONLINE_SALE S
JOIN USER_INFO I
ON S.USER_ID = I.USER_ID
WHERE I.GENDER IS NOT NULL
GROUP BY YEAR, MONTH, I.GENDER
ORDER BY YEAR,MONTH,I.GENDER


-- 우유와 요거트가 담긴 장바구니 --
SELECT Y.CART_ID
FROM (
SELECT DISTINCT CART_ID --요거트 담긴 카트만 중복 없이 가져온다.
FROM CART_PRODUCTS 
WHERE NAME = 'Yogurt') AS Y
JOIN(
SELECT DISTINCT CART_ID -- 우유가 담긴 카트만 중복 없이 가져온다.
FROM CART_PRODUCTS 
WHERE NAME = 'Milk') AS M
ON Y.CART_ID = M.CART_ID -- 두개의 테이블에서 ID가 같은것만 출력
ORDER BY Y.CART_ID

SELECT CART_ID
FROM CART_PRODUCTS
WHERE NAME = 'Milk' AND CART_ID IN ( -- 테이블을 둘다 구하는게 아니라 한쪽만 구하고 다른한쪽으로 이런식으로도 구현가능하다.
    SELECT CART_ID
    FROM CART_PRODUCTS
    WHERE NAME = 'Yogurt'
)
ORDER BY CART_ID;


-- 취소되지 않은 진료 예약 조회하기 --
SELECT A.APNT_NO, P.PT_NAME,P.PT_NO, D.MCDP_CD, D.DR_NAME, A.APNT_YMD
FROM DOCTOR D
JOIN APPOINTMENT A
ON A.APNT_CNCL_YN = 'N' AND D.DR_ID = A.MDDR_ID AND A.MCDP_CD = 'CS' -- 일단 의사 테이블과 진료테이블에서 해당 조건에 만족하는 진료만 가져온다.
JOIN PATIENT P
ON A.PT_NO = P.PT_NO -- 가져온 정보에서 환자테이블에서 해당 환자 데이터를 가져온다.
WHERE LEFT(A.APNT_YMD,10) = '2022-04-13' -- 해당일에 속하는 데이터만 출력
ORDER BY A.APNT_YMD


-- 주문량이 많은 아이스크림들 조회하기 --
SELECT F.FLAVOR
FROM FIRST_HALF F
JOIN(
SELECT FLAVOR, SUM(TOTAL_ORDER) AS TOTAL_ORDER
FROM JULY
GROUP BY FLAVOR) AS J -- 미리 7월의 각 맛별로 총 주문량을 구해온다.
ON F.FLAVOR = J.FLAVOR -- 두개의 테이블을 조인
GROUP BY F.FLAVOR -- 맛별로 그룹화 한다.
ORDER BY F.TOTAL_ORDER + J.TOTAL_ORDER DESC --두개의 총 주문량을 더한값을 기준으로 내림차순 정렬
LIMIT 3 -- 그중 3개만 출력


-- 저자 별 카테고리 별 매출액 집계하기 --
SELECT A.AUTHOR_ID, A.AUTHOR_NAME, B.CATEGORY, SUM(S.SALES * B.PRICE) AS TOTAL_SALES -- 해당그룹에서 각 책들의 총판매가격을 합해서 출력
FROM BOOK B
JOIN AUTHOR A
ON B.AUTHOR_ID = A.AUTHOR_ID
JOIN BOOK_SALES S
ON B.BOOK_ID = S.BOOK_ID -- 3개의 테이블을 연관된것끼리 JOIN하여 하나의 테이블로 생성
WHERE LEFT(S.SALES_DATE,7) = '2022-01' -- 그중 날짜가 조건에 맞는 애들만 가져온다.
GROUP BY A.AUTHOR_ID, B.CATEGORY -- ID와 카테고리로 그룹을 형성시킨다.
ORDER BY A.AUTHOR_ID,B.CATEGORY DESC


-- 그룹별 조건에 맞는 식당 목록 출력하기 --
SELECT M.MEMBER_NAME, R.REVIEW_TEXT, LEFT(R.REVIEW_DATE, 10) AS REVIEW_DATE
FROM REST_REVIEW R
JOIN MEMBER_PROFILE M
ON M.MEMBER_ID = R.MEMBER_ID
WHERE R.MEMBER_ID = (
    SELECT MEMBER_ID
    FROM REST_REVIEW
    GROUP BY MEMBER_ID
    ORDER BY COUNT(MEMBER_ID) DESC
    LIMIT 1 -- 리미트를 이용하여 최댓값에 해당하는 아이디 가져오기
)
ORDER BY REVIEW_DATE, R.REVIEW_TEXT


-- 입양 시각 구하기(2) --
-- 없는 필드를 생성한다.
WITH RECURSIVE TIME AS (
SELECT 0 as n
UNION ALL
SELECT n + 1 FROM TIME WHERE n < 23
)

SELECT T.N, IFNULL(A.CNT, 0) AS COUNT -- 만약 A.CNT 값이 없다면 0으로 넣어준다.
FROM TIME T
LEFT JOIN (
    SELECT HOUR(DATETIME) AS HOUR, COUNT(*) AS CNT
    FROM ANIMAL_OUTS
    GROUP BY HOUR(DATETIME)
) AS A
ON T.N = A.HOUR


-- 오프라인/온라인 판매 데이터 통합하기 --
-- 코드를 입력하세요
SELECT LEFT(A.SALES_DATE, 10) AS SALES_DATE, A.PRODUCT_ID, A.USER_ID, A.CNT AS SALES_AMOUNT
FROM (
    -- 유니온을 사용하여 두개의 데이터 베이스를 합친다.(JOIN이랑은 다르다 UNION은 그냥 진짜 합친다)
    SELECT SALES_DATE, SALES_AMOUNT AS CNT, USER_ID, PRODUCT_ID
    FROM ONLINE_SALE
    UNION ALL
    SELECT SALES_DATE, SALES_AMOUNT AS CNT, NULL AS USER_ID, PRODUCT_ID
    FROM OFFLINE_SALE
) AS A
WHERE LEFT(A.SALES_DATE, 7) = '2022-03'
ORDER BY A.SALES_DATE, A.PRODUCT_ID, A.USER_ID


-- 특정 기간동안 대여 가능한 자동차들의 대여비용 구하기 --
SELECT C.CAR_ID, C.CAR_TYPE, ROUND((C.DAILY_FEE*30) / 100) * (100-P.DISCOUNT_RATE) AS FEE
FROM CAR_RENTAL_COMPANY_CAR C
JOIN CAR_RENTAL_COMPANY_DISCOUNT_PLAN  P
ON C.CAR_TYPE = P.CAR_TYPE AND P.DURATION_TYPE LIKE "%30%"
WHERE C.CAR_TYPE IN ('SUV', '세단') 
AND C.CAR_ID NOT IN (
    SELECT CAR_ID
    FROM CAR_RENTAL_COMPANY_RENTAL_HISTORY
    WHERE LEFT(START_DATE, 10) <= '2022-11-30' 
            AND LEFT(END_DATE, 10) >= '2022-11-01'
) 
HAVING FEE >= 500000 AND FEE < 2000000
ORDER BY FEE DESC, C.CAR_TYPE, C.CAR_ID


-- 자동차 대여 기록 별 대여 금액 구하기 --
SELECT H.HISTORY_ID,
ROUND(CASE
WHEN DATEDIFF(H.END_DATE, H.START_DATE)+1 < 7 THEN C.DAILY_FEE * (DATEDIFF(H.END_DATE, H.START_DATE)+1)

WHEN DATEDIFF(H.END_DATE, H.START_DATE)+1 < 30 THEN C.DAILY_FEE * (DATEDIFF(H.END_DATE, H.START_DATE)+1)/100 * 
(100-(SELECT DISCOUNT_RATE FROM CAR_RENTAL_COMPANY_DISCOUNT_PLAN WHERE DURATION_TYPE LIKE '%7%' AND CAR_TYPE = '트럭'))

WHEN DATEDIFF(H.END_DATE, H.START_DATE)+1 < 90 THEN C.DAILY_FEE * (DATEDIFF(H.END_DATE, H.START_DATE)+1)/100 * 
(100-(SELECT DISCOUNT_RATE FROM CAR_RENTAL_COMPANY_DISCOUNT_PLAN WHERE DURATION_TYPE LIKE '%30%' AND CAR_TYPE = '트럭'))

ELSE C.DAILY_FEE * (DATEDIFF(H.END_DATE, H.START_DATE)+1)/100 * 
(100-(SELECT DISCOUNT_RATE FROM CAR_RENTAL_COMPANY_DISCOUNT_PLAN WHERE DURATION_TYPE LIKE '%90%' AND CAR_TYPE = '트럭'))

END, 0) AS FEE
FROM CAR_RENTAL_COMPANY_RENTAL_HISTORY H
JOIN CAR_RENTAL_COMPANY_CAR C
ON H.CAR_ID = C.CAR_ID
WHERE C.CAR_TYPE = '트럭'
ORDER BY FEE DESC, H.HISTORY_ID DESC